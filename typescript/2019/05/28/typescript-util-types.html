<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><title>Typescript의 기본 유틸 타입 | Typescript 내의 유틸 타입 톹아보기 | Martin</title><meta name="keywords" content="'Typescript', 'Util type', '유틸 타입',  Typescript, 타입스크립트, 유틸 타입, Partial, Required, Readonly, Pick, Record, Exclude, Extract, Omit, NonNullable, ReturnType, "><meta name="description" content="Typescript 내의 유틸 타입 톹아보기, Typescript 내의 유틸 타입 톹아보기,Typescript의 기본 유틸 타입"><meta property="og:image" content="/images/typescript/typescript.png"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="[object Object]"><meta name="designer" content="Martin"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="http://blog.martinwork.co.kr/typescript/2019/05/28/typescript-util-types.html"><link rel="icon" type="image/png" href="/images/favicon/favicon-32x32.png" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="프론트엔드 개발자 Martin의 사적인 블로그"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-109243056-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-109243056-1")</script><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(undefined)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="프론트엔드 개발자 Martin의 사적인 블로그" alt="프론트엔드 개발자 Martin의 사적인 블로그"><img src="/images/bg/logo_white_text.png" alt="프론트엔드 개발자 Martin의 사적인 블로그"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="Home" title="Home">Home</a></li><li class="nav__item"><a href="/archives" alt="Archive" title="Archive">Archive</a></li><li class="nav__item"><a href="/about" alt="About" title="About">About</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="/images/typescript/typescript.png" alt="Typescript의 기본 유틸 타입"></div><header class="post__info"><h1 class="post__title">Typescript의 기본 유틸 타입</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="https://github.com/martinYounghoonKim">Martin</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2019-05-28</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/typescript/">Typescript</a></li><li class="mark__item"><a href="/tags/util-type/">Util Type</a></li><li class="mark__item"><a href="/tags/유틸-타입/">유틸 타입</a></li></ul></div></div></header><div class="post__content"><p>타입스크립트를 이용해서 개발을 한지 어느덧 1년이 조금 넘은 것 같다. 현재의 직장으로 옮기기 전에는 VueJS와 타입스크립트 조합으로 사용을 하였고, 지금은 ReactJS와 타입스크립틀 조합으로 사용하고 있다.</p><p><img src="/images/typescript/vue-vs-react-business-perspective-v2.jpg" alt="/images/typescript/vue-vs-react-business-perspective-v2.jpg"></p><p>타입스크립트로 프로젝틀를 진행을 하며 처음에는 인터페이스와 모듈에 대한 인풋/아웃풋의 타입에만 신경을 쓰고, 비효율적인 인터페이스 선언에 대한 고려는 크게 하지 않았다. 사실은 알면서도 모른 척 했을 수도 있다. 하지만 비지니스가 점점 더 복잡해짐에 따라 인터페이스를 효율적으로 관리해야하는 니즈가 생겼다. 간단한 프로젝트에서는 모델에 대한 인터페이스 선언을 해도 그 수가 많지 않았지만, 지금은 선언된 모듈 인터페이스만 해도 그 수가 기하급수적으로 많아지기 시작했다. 그러던 중 타입스크립트 내에서 제공해주는 유틸 타입을 보게 되었고, 추가적인 라이브러리 내에서 지원하는 유틸 타입을 보게 되었다. 물론 라이브러리에서 지원하는 모든 유틸 타입이 다 필요한 것은 아니기에, 살펴보고 필요하다라고 판단되는 것은 일부 정의해서 쓰기로 했다. 그 중 유용하다고 생각하는 유틸 타입이나 타입스크립트에서 제공해주는 유틸 타입에 대해서 살펴보았다.</p><h3 id="타입스크립트에서-기본적으로-제공해주는-유틸-타입"><a href="#타입스크립트에서-기본적으로-제공해주는-유틸-타입" class="headerlink" title="타입스크립트에서 기본적으로 제공해주는 유틸 타입"></a>타입스크립트에서 기본적으로 제공해주는 유틸 타입</h3><h4 id="Partial-유틸-타입"><a href="#Partial-유틸-타입" class="headerlink" title="Partial 유틸 타입"></a>Partial<t>유틸 타입</t></h4><p>Partial 타입은 제네릭 타입 T에 대해서 모든 프로퍼티들을 Optional하게 변경한다. 정의된 Patial 타입을 살펴보면 아래와 같이 선언되어져 있다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;    </span><br><span class="line">	[P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Patial 타입은 제네릭 타입의 T 타입의 Public Property 들에 대하여 기존의 타입은 유지하되, 각각의 Property 들을 Optional 타입으로 변경해준다.</p><h5 id="keyof-T-와-T-K"><a href="#keyof-T-와-T-K" class="headerlink" title="keyof T 와 T[K]"></a>keyof T 와 T[K]</h5><p>Indexed type query인 keyof T는 제네릭 타입 T의 Public Property 들에 대한 Union 타입이다. 우리에게 익숙한 TODO에 대한 인터페이스를 통해 살펴보면 다음과 같다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">	id: <span class="built_in">string</span>;</span><br><span class="line">	text: <span class="built_in">string</span>;</span><br><span class="line">	isDone: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Key = keyof Todo; <span class="comment">// "id" | "text" | "isDone"</span></span><br></pre></td></tr></table></figure><p>이러한 keyof 는 문자열(String) 타입의 서브 타입이다. 이러한 keyof 키워드와 함께 자주 쓰이는 연산자가 있다. 위에서 Partial 타입에서 살펴봤던 T[K]이다. Indexed access operator 인 T[K] 연산자 덕분에 Partial 타입이 기존의 타입을 유지한 상태에서 각각의 Property들을 Optional 한 타입으로 변경해줄 수 있었다. Indexed type query와 Index access operator를 응용한다면 아래와 같이 type-safe 한 값들을 가져올 수 있다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">todo: T, key: K</span>): <span class="title">T</span>[<span class="title">K</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> todo[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">	id: <span class="built_in">string</span>;</span><br><span class="line">	text: <span class="built_in">string</span>;</span><br><span class="line">	isDone: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OptionalTodo1 = Partial&lt;Todo&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OptionalTodo1 와 OptionalTodo2 는 동일한 타입이다.</span></span><br><span class="line"><span class="keyword">interface</span> OptionalTodo2 &#123;</span><br><span class="line">	id?: <span class="built_in">string</span>;</span><br><span class="line">	text?: <span class="built_in">string</span>;</span><br><span class="line">	isDone?: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이러한 Partial 타입을 이용하여 인터페이스 안에 혼재 되어 있는 타입들에 대하여 Required 타입과 Optional 타입을 분리할 수 있다는 장점이 있다. 사용자 정보에 대한 모델 타입이 있다고 가정해보자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> UserInformation &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  uid: <span class="built_in">string</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">  profile?: <span class="built_in">string</span>;</span><br><span class="line">  phone?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>물론 이러한 형태로 작성해도 문제는 없을 것이다. 하지만 상황에 따라 Required 타입와 Optional 타입을 분리해야할 상황이 있다. 예를 들어 별도의 API 거쳐 Service Layer 를 통해 Optional한 값에 대하여 기본값을 추가해주는 일종의 Generate 함수의 Parameter 등이 있을 것이다. (이에 대한 자세한 설명은 비즈니스 코드를 작성하는 개인의 취향 혹은 팀 내의 컨벤션이므로 깊이있게 설명하진 않는다.) 이러한 경우 아래와 필요성에 따라 아래와 같이 분리할 수 있다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UserInformation = RequiredUserInformation &amp; Partial&lt;OptionalUserInformation&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> RequiredUserInformation &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  uid: <span class="built_in">string</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> OptionalUserInformation &#123;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  profile: <span class="built_in">string</span>;</span><br><span class="line">  phone: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Required-타입"><a href="#Required-타입" class="headerlink" title="Required 타입"></a>Required<t>타입</t></h4><p>Required 타입은 앞서 살핀 Partial 유틸 타입과는 반대의 개념이다. Partial 유틸 타입은 모든 프로퍼티를 Optional로 만들어줬다면 Required 타입은 제네릭 타입 T의 모든 프로퍼티에 대해 Required 속성으로 만들어준다.<br></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Required&lt;T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]-?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>Patial 타입과 동일하게 기존의 값은 유지된 상태에서 Requied 타입으로 변경된다는 것을 꼭 인지하도록 하자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> OptionalTodo &#123;</span><br><span class="line">    id: <span class="built_in">string</span>;</span><br><span class="line">    text?: <span class="built_in">string</span>;</span><br><span class="line">    isDone?: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 타입 Todo1과 타입 Todo2 는 동일한 타입이다.</span></span><br><span class="line"><span class="keyword">type</span> Todo1 = Required&lt;OptionalTodo&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Todo2 &#123;</span><br><span class="line">    id: <span class="built_in">string</span>;</span><br><span class="line">    text: <span class="built_in">string</span>;</span><br><span class="line">    isDone: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly<t></t></h4><p>Readonly 타입을 이용하면 주어진 제네릭 타입 T의 모든 프로퍼티가 readonly 속성을 갖도록 변경한다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">    readonly [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>readonly를 이용하는 대표적인 경우가 React 컴포넌트의 Props와 State 값이 이에 해당한다. 우리는 모두 알듯, React 내에서의 모든 Props 와 State 는 Immutable이다. 그렇기 때문에 직접적으로 변경해서는 안된다. 이러한 상황에서 Readonly 타입을 이용할 수 있다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Component&lt;P, S&gt; &#123;</span><br><span class="line">    <span class="comment">// 중간 생략</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">props: Readonly&lt;P&gt;</span>);</span><br><span class="line">  setState&lt;K extends keyof S&gt;(<span class="params"></span></span><br><span class="line"><span class="params">      state: ((prevState: Readonly&lt;S&gt;, props: Readonly&lt;P&gt;) =&gt; (Pick&lt;S, K&gt; | S | <span class="literal">null</span>)) | (Pick&lt;S, K&gt; | S | <span class="literal">null</span>),</span></span><br><span class="line"><span class="params">      callback?: () =&gt; <span class="built_in">void</span></span></span><br><span class="line"><span class="params">  </span>): void;</span><br><span class="line">  state: Readonly&lt;S&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>혹은 immutable-js과 같은 데이터의 불변성을 보장해주는 라이브러리나 혹은 Javascript의 freeze 함수에 사용할 때 유용하게 사용할 수 있다. 예를 들어 Object를 얕은 동결을 지원하는 freeze 함수를 사용하는 경우 모든 함수의 경우 readonly 속성을 가져야 함으로 이럴 때 유용하게 사용할 수 있다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">freeze</span>&lt;<span class="title">T</span>&gt;(<span class="params">obj: T</span>): <span class="title">Readonly</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Pick-lt-T-K-gt"><a href="#Pick-lt-T-K-gt" class="headerlink" title="Pick&lt;T, K&gt;"></a>Pick&lt;T, K&gt;</h4><p>Pick 타입은 주어진 첫번째 제네릭 타입 T 내에서 Union 타입 K에 대한 프로퍼티에 대한 타입들을 뽑아낸다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>익숙한 TODO를 통해 Pick 타입을 사용하는 예제를 살펴보도록 하자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  isDone: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TodoWithIdAndTitle 타입과 PickedTodo 타입은 동일한 타입이다.</span></span><br><span class="line"><span class="keyword">type</span> TodoWithIdAndTitle = Pick&lt;Todo, <span class="string">'id'</span> | <span class="string">'title'</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PickedTodo &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이러한 Pick 타입을 이용한다면 필요한 타입만 추출하여 원하는 새로운 타입을 만들 수 있다.</p><h4 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h4><p>Record 타입은 총 두개의 제네릭 타입을 받을 수 있다. 첫번째 제네릭 타입 K은 프로퍼티 타입으로, 두번째 제네릭 타입 T은 값의 타입으로 사용된다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Record&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]: T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Record 타입의 구조체를 살펴보면 일반적으로 사용하는 Object와 닮은 꼴을 하고 있다는 것을 알 수 있다. 아래와 같이 사용할 수 있다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IFooBar = &#123;</span><br><span class="line">  foo: <span class="built_in">string</span>;</span><br><span class="line">  bar: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IHelloWorld = <span class="string">'hello'</span> | <span class="string">'world'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x: Record&lt;IHelloWorld, IFooBar&gt; = &#123;</span><br><span class="line">  hello: &#123;</span><br><span class="line">    foo: <span class="string">'foo'</span>,</span><br><span class="line">    bar: <span class="string">'bar'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  world: &#123;</span><br><span class="line">    foo: <span class="string">'foo'</span>,</span><br><span class="line">    bar: <span class="string">'bar'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Exclude"><a href="#Exclude" class="headerlink" title="Exclude"></a>Exclude</h4><p>Exclude 타입은 2개의 제네릭 타입을 받을 수 있으며, 조건부 타입(Conditional type)을 이용하여 타입을 정의 한다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Exclude&lt;T, U&gt; = T <span class="keyword">extends</span> U ? never : T;</span><br></pre></td></tr></table></figure><p>두번째 제네릭 타입에 대하여 첫번째 제네릭 타입이 할당 가능한 타입(Assignable)인지를 여부를 판단하여 할당 가능한 타입을 제외한 나머지 타입들을 이용하여 타입을 정의한다. 이해하기 쉽도록 아래의 예제를 살펴보도록 하자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  isDone: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Memo &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  content: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Contents = Exclude&lt;Todo | Memo, Memo&gt;;</span><br></pre></td></tr></table></figure><p>위에서 살펴본 할당 가능한(Assignable) 타입을 제외한다면 Cotents 타입은 어떠한 타입을 가지게 될까 ? 두번째 제네릭 타입 U에 해당하는 Memo에 대하여 첫번째 제네릭 타입에 해당하는 Todo와 Memo 중 할당 불가능한 타입은 Todo 타입이 될 것이다.</p><h4 id="Extract"><a href="#Extract" class="headerlink" title="Extract"></a>Extract</h4><p>Extract 유틸 타입은 단어 그대로 추출의 의미를 가지며, Exclude 타입과 반대의 타입이다. 첫번째 제네릭 타입 U에 대하여 제네릭 타입 T 중 할당 가능한 타입을 할당한다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Extract&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : never;</span><br></pre></td></tr></table></figure><p>Exclude 타입에서 살펴보았던 예제를 다시 한번 살펴보도록 하자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Todo = &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  isDone: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Memo = &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  content: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Contents = Extract&lt;Todo | Memo, Memo&gt;;</span><br></pre></td></tr></table></figure><p>Exclude 타입과는 다르게 유니온 타입 Todo과 Memo에 대하여 Memo에 할당 타입을 반환하기 때문에 Contents 타입은 Memo 타입이 되는 것을 알 수 있다.</p><h4 id="Omit"><a href="#Omit" class="headerlink" title="Omit"></a>Omit</h4><p>Omit 타입은 두개의 제네릭 타입을 받으며 첫번째 제네릭 타입 T에 대하여 두번째 제네릭 타입 K의 값을 제외한 나머지 값을 반환합니다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Omit&lt;T, K <span class="keyword">extends</span> keyof <span class="built_in">any</span>&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;</span><br></pre></td></tr></table></figure><p>정의된 Omit의 타입을 살펴보면 앞서 우리가 익혔던 타입들을 이용하여 정의하고 있다. 예제를 통해 정의된 타입들을 Todo 인터페이스의 예제를 가지고 이해해보도록 하자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  isDone: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> TodoWithOutId = Omit&lt;Todo, <span class="string">"id"</span>&gt;;</span><br></pre></td></tr></table></figure><p>일단 Exclude 타입을 통해 살펴보면 keyof T 에 해당하는 Todo 타입의 프로퍼티 중 두번째 제네릭 타입 K에 해당하는 id를 제외한 나머지 값들을 뽑아낸다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pick&lt;Todo, <span class="string">"title"</span> | <span class="string">"isDone"</span>&gt;;</span><br></pre></td></tr></table></figure><p>그렇게 Exclude를 통해 뽑아낸 유니온 타입들에 대하여 Pick 타입을 이용하여 Todo 타입 중 그에 해당하는 프로퍼티의 타입을 뽑아낸다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  isDone: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> TodoWithOutId = Omit&lt;Todo, <span class="string">"id"</span>&gt;;</span><br><span class="line"><span class="comment">// TodoWithOutId의 타입은 아래의 인터페이스와 일치한다.</span></span><br><span class="line"><span class="keyword">interface</span> TodoWithOutId &#123;</span><br><span class="line">    title: <span class="built_in">string</span>;</span><br><span class="line">  isDone: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NonNullable"><a href="#NonNullable" class="headerlink" title="NonNullable"></a>NonNullable</h4><p>NonNullable 유틸타입은 주어진 제네릭 타입 안에서 null이나 undefined을 제거한다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NonNullable&lt;T&gt; = T <span class="keyword">extends</span> <span class="literal">null</span> | <span class="literal">undefined</span> ? never : T;</span><br></pre></td></tr></table></figure><p>이미 앞에서 살펴봤던 타입들을 모두 이해했다면 이와 같은 Conditional type(조건부 타입)은 이해하기 어렵지 않을 것이다. 간단한 예제를 통해 살펴보면 후, 넘어가도록 하자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Todo = &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  isDone: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NullableTodos = <span class="literal">null</span> | <span class="literal">undefined</span> | Todo[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Todos = NonNullable&lt;NullableTodos&gt;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * type Todos = Todo[];</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h2><p>ReturnType 타입은 주어진 제네릭 타입 T의 return type을 할당한다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReturnType&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; infer R ? R : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure><p>여기에서 익숙하지 않은 infer 키워드가 등장하는데, 간단히 이야기하자면 해당 <code>타입을 추론</code> 하고자 할 때 사용하는 키워드라고 생각하면 된다. 관련해서 조금더 자세히 알아보고자 한다면 <a href="https://dev.to/aexol/typescript-tutorial-infer-keyword-2cn" target="_blank" rel="noopener">https://dev.to/aexol/typescript-tutorial-infer-keyword-2cn</a> 를 참고하도록 하자. 그래서 위에서의 반환 타입을 분석해보자면, <code>T extends (...args: any) =&gt; infer R ? R : any</code> 는 R 타입에 대해서 타입 추론이 가능하다면 R 타입을 그렇지 않다면 any 타입을 반환한다. ReturnType 의 경우 해당 함수에 대한 반환 타입을 타이핑할 때 사용할 수 있다. 아마 Redux 를 사용해본 사람이라면 이러한 ReturnType을 ActionCreator 함수에서 활용할 수 있음을 깨달을 수 있을 것이다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPayload &#123;</span><br><span class="line">  foo: <span class="built_in">string</span>;</span><br><span class="line">  bar: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fooBarCreator = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    foo: <span class="string">"foo"</span>, bar: <span class="string">"bar"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IFooBarCreator = ReturnType&lt;<span class="keyword">typeof</span> fooBarCreator&gt;;</span><br></pre></td></tr></table></figure><h3 id="기타-유용한-유틸-타입"><a href="#기타-유용한-유틸-타입" class="headerlink" title="기타 유용한 유틸 타입"></a>기타 유용한 유틸 타입</h3><p>타입스크립트에서 제공해주는 유틸 타입을 제외하더라도 개인적으로 커스텀해서 사용하기 좋아하는 타입들 역시 있다. 이러한 유용한 유틸 타입 중 일부에 대해서는 아래의 링크에 <code>conditional-type-checks</code>를 참고하였으며, 기타는 회사에서 업무를 진행하며 필요하다는 생각이 들어 추가한 것들도 있다.</p><h4 id="Nullable"><a href="#Nullable" class="headerlink" title="Nullable"></a>Nullable</h4><p>Javascript로 개발을 할때는 Object를 초기화할때 null을 이용하여 초기화 시켜줬다. 이러한 객체는 선언시 null 타입을 가질 수도 혹은 이후 할당된 객체의 값을 가질 수 있어야 한다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> INullable&lt;T&gt; = T | <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">interface</span> ITodos &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  text: <span class="built_in">string</span>;</span><br><span class="line">  isDone: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchTodo</span> (<span class="params"></span>): <span class="title">Promise</span>&lt;<span class="title">INullable</span>&lt;<span class="title">ITodos</span>&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// request api</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">fetchTodo().then(<span class="function"><span class="params">todo</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 서버의 응답값이 null일 수 있기 때문에 방어코드를 추가해준다.</span></span><br><span class="line">  <span class="keyword">if</span>(!todo) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>개인적으로는 보통 서버와의 통신을 제어하는 래퍼 함수(Wrapper function)의 리턴 타입의 인터페이스에 사용한다. 이렇게 작성된 인터페이스로 인해 일차적으로는 서버의 응답값과의 정합률이 높아질 뿐만 아니라 자칫 놓치고 넘어갈 수 있는 방어 코드에 대해서도 컴파일 단계에서 미리 알아차릴 수 있다는 장점이 있다.</p><h4 id="Maybe"><a href="#Maybe" class="headerlink" title="Maybe"></a>Maybe</h4><p>프론트 개발을 하다보면 아무리 정해져 있는 API 규약에 맞춰 백엔드 서버와 커뮤니케이션 한다고 하더라도 실제 정해져있는 규약으로 넘어오지 않는 경우가 많다. 그러한 경우 값이 없을 때의 타입이 null인지, undefined인지 알 수가 없다. 물론 아예 해당하는 키의 데이터가 안내려올때도 있지만 그러한 경우는 optional 옵션을 이용하여 인터페이스를 선언하면 되지만, 타입이 명확하지 않은 경우는 런타임 환경에서 타입 에러에 직면하는 경우가 많다. 그런 경우를 대비하며 Nullable 타입과 분리하여 Maybe 유틸 타입을 선언하여 사용한다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IMaybe&lt;T&gt; = T | <span class="literal">undefined</span> | <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>이 외에도 AJAX의 응답값에 대한 래퍼 함수의 리턴 타입 등을 커스텀해서 사용하고 있지만, 이외에는 생각나는 유틸 타입은 없는 것 같다. 이 외에도 이러한 유용한 유틸 타입을 제공해주는 라이브러리가 있다. 혹시나 또다른 유틸 타입이 필요하다면 아래의 참고 링크를 참고하는 것도 좋을 것 같다.</p><p>혹시나 이 글을 보시고, 커스텀으로 사용하고 있는 또다른 좋은 유틸 타입이 있다면 여러분의 타입도 한번 공유 부탁드립니다.😄</p><hr><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://github.com/microsoft/TypeScript-Handbook/blob/master/pages/Utility%20Types.md" target="_blank" rel="noopener">Typescript handbook</a></li><li><a href="https://github.com/dsherret/conditional-type-checks" target="_blank" rel="noopener">conditional-type-checks</a></li><li><a href="https://github.com/piotrwitek/utility-types" target="_blank" rel="noopener">utility-types</a></li></ul><div class="post-announce">현재 이커머스회사에서 frontend 개발자로 업무를 진행하고 있는 <a href="https://github.com/martinYounghoonKim">Martin</a> 입니다. 글을 읽으시고 궁금한 점은 댓글 혹은 메일(hoons0131@gmail.com)로 연락해주시면 빠른 회신 드리도록 하겠습니다. 이 외에도 네트워킹에 대해서는 언제나 환영입니다.：Martin（<a href="https://github.com/martinYounghoonKim">https://github.com/martinYounghoonKim</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/devops/2019/05/24/server-side-rendering01.html" title="왜 다시 SSR인가 01"><i class="iconfont icon-prev"></i>왜 다시 SSR인가 01</a></div><div class="post__prev post__prev--right"><a href="/review/2019/06/01/likelion-hackerton.html" title="멋사 해커톤 참여기">멋사 해커톤 참여기<i class="iconfont icon-next"></i></a></div></div></div></article><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-6986373452203090" data-ad-slot="3762948283" data-ad-format="auto" data-full-width-responsive="true"></ins><script>window.onload=function(){(adsbygoogle=window.adsbygoogle||[]).push({})}</script><div id="disqus_thread"></div></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">Introduction</h3><p class="block__text">E-Commerce에서 Front-end 개발을 하고 있는 마틴입니다. 안정성 있는 서비스 구축과 TDD 프로그래밍에 관심이 많으며, 긍정적인 네트워킹에 대해서도 언제나 환영입니다. 저와의 네트워킹을 원하시는 분은 언제든 편하게 SNS나 게시글의 댓글 혹은 이메일을 통해 연락주시면 최대한 빨리 회신드리도록 하겠습니다:)</p></div><div class="sidebar__block"><h3 class="block__title">Categories</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/theory/">theory</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/webpack/">Webpack</a><span class="block-list-count">6</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/vuejs/">VueJS</a><span class="block-list-count">9</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/unit-test/">Unit Test</a><span class="block-list-count">3</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/typescript/">Typescript</a><span class="block-list-count">6</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/theory/">Theory</a><span class="block-list-count">12</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/review/">Review</a><span class="block-list-count">12</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/reactjs/">ReactJS</a><span class="block-list-count">2</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/react/">React</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/nodejs/">NodeJS</a><span class="block-list-count">3</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/nestjs/">NestJS</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/mysql/">Mysql</a><span class="block-list-count">2</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/kotlin/">Kotlin</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/javascript/">Javascript</a><span class="block-list-count">15</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/devops/">Devops</a><span class="block-list-count">10</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/ai/">AI</a><span class="block-list-count">3</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">Latest Post</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/nestjs/2020/03/22/what-is-nestjs.html" title="01. NestJS란"><div class="item__cover"><img src="/images/nestjs/nestjs00.png" alt="01. NestJS란"></div><div class="item__info"><h3 class="item__title">01. NestJS란</h3><span class="item__text">2020-03-22</span></div></a></li><li class="latest-post-item"><a href="/mysql/2020/01/17/mysql-data-type.html" title="MYSQL 데이터 타입"><div class="item__cover"><img src="/images/mysql/mysql.png" alt="MYSQL 데이터 타입"></div><div class="item__info"><h3 class="item__title">MYSQL 데이터 타입</h3><span class="item__text">2020-01-17</span></div></a></li><li class="latest-post-item"><a href="/review/2020/01/07/remembrance-in-2019.html" title="2019년의 회고"><div class="item__cover"><img src="/images/review/retro01.jpg" alt="2019년의 회고"></div><div class="item__info"><h3 class="item__title">2019년의 회고</h3><span class="item__text">2020-01-07</span></div></a></li><li class="latest-post-item"><a href="/theory/2019/12/15/ipv4-address.html" title="IPv4 주소 체계"><div class="item__cover"><img src="/images/theory/ipv4-address00.png" alt="IPv4 주소 체계"></div><div class="item__info"><h3 class="item__title">IPv4 주소 체계</h3><span class="item__text">2019-12-15</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">Tags</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/2018회고/">2018회고</a></li><li class="tag-item"><a class="tag-link" href="/tags/2019회고-coupang-쿠팡/">2019회고, Coupang, 쿠팡</a></li><li class="tag-item"><a class="tag-link" href="/tags/ai/">AI</a></li><li class="tag-item"><a class="tag-link" href="/tags/aws/">AWS</a></li><li class="tag-item"><a class="tag-link" href="/tags/aws-s3/">AWS S3</a></li><li class="tag-item"><a class="tag-link" href="/tags/array/">Array</a></li><li class="tag-item"><a class="tag-link" href="/tags/authenticate/">Authenticate</a></li><li class="tag-item"><a class="tag-link" href="/tags/awwwards-2018/">Awwwards 2018</a></li><li class="tag-item"><a class="tag-link" href="/tags/back-end/">Back-end</a></li><li class="tag-item"><a class="tag-link" href="/tags/backend/">Backend</a></li><li class="tag-item"><a class="tag-link" href="/tags/binary-search/">Binary Search</a></li><li class="tag-item"><a class="tag-link" href="/tags/csr/">CSR</a></li><li class="tag-item"><a class="tag-link" href="/tags/chai/">Chai</a></li><li class="tag-item"><a class="tag-link" href="/tags/chrome-extension/">Chrome extension</a></li><li class="tag-item"><a class="tag-link" href="/tags/clean-code/">Clean code</a></li><li class="tag-item"><a class="tag-link" href="/tags/commonjs/">CommonJS</a></li><li class="tag-item"><a class="tag-link" href="/tags/conference/">Conference</a></li><li class="tag-item"><a class="tag-link" href="/tags/cookie/">Cookie</a></li><li class="tag-item"><a class="tag-link" href="/tags/database/">Database</a></li><li class="tag-item"><a class="tag-link" href="/tags/dev-ops/">Dev-ops</a></li><li class="tag-item"><a class="tag-link" href="/tags/devops/">Devops</a></li><li class="tag-item"><a class="tag-link" href="/tags/docker/">Docker</a></li><li class="tag-item"><a class="tag-link" href="/tags/ecma-script/">ECMA script</a></li><li class="tag-item"><a class="tag-link" href="/tags/eslint/">Eslint</a></li><li class="tag-item"><a class="tag-link" href="/tags/express/">Express</a></li><li class="tag-item"><a class="tag-link" href="/tags/first-class-object/">First Class Object</a></li><li class="tag-item"><a class="tag-link" href="/tags/flux/">Flux</a></li><li class="tag-item"><a class="tag-link" href="/tags/google-cloud-platform/">Google Cloud Platform</a></li><li class="tag-item"><a class="tag-link" href="/tags/hash-table/">Hash table</a></li><li class="tag-item"><a class="tag-link" href="/tags/ipv4-network-ip/">IPv4, Network, IP</a></li><li class="tag-item"><a class="tag-link" href="/tags/immutablejs/">ImmutableJS</a></li><li class="tag-item"><a class="tag-link" href="/tags/jwt/">JWT</a></li><li class="tag-item"><a class="tag-link" href="/tags/jwt-token/">JWT Token</a></li><li class="tag-item"><a class="tag-link" href="/tags/javascript/">Javascript</a></li><li class="tag-item"><a class="tag-link" href="/tags/javascript-framework/">Javascript Framework</a></li><li class="tag-item"><a class="tag-link" href="/tags/javascript-method/">Javascript Method</a></li><li class="tag-item"><a class="tag-link" href="/tags/javascript-디자인-패턴/">Javascript 디자인 패턴</a></li><li class="tag-item"><a class="tag-link" href="/tags/karma/">Karma</a></li><li class="tag-item"><a class="tag-link" href="/tags/linear-regression/">Linear Regression</a></li><li class="tag-item"><a class="tag-link" href="/tags/list/">List</a></li><li class="tag-item"><a class="tag-link" href="/tags/machine-learning/">Machine learning</a></li><li class="tag-item"><a class="tag-link" href="/tags/mocha/">Mocha</a></li><li class="tag-item"><a class="tag-link" href="/tags/moment/">Moment</a></li><li class="tag-item"><a class="tag-link" href="/tags/momentjs/">MomentJS</a></li><li class="tag-item"><a class="tag-link" href="/tags/mongodb/">MongoDB</a></li><li class="tag-item"><a class="tag-link" href="/tags/mysql/">Mysql</a></li><li class="tag-item"><a class="tag-link" href="/tags/mysql-데이터타입/">Mysql, 데이터타입</a></li><li class="tag-item"><a class="tag-link" href="/tags/naver-tech-concert/">Naver Tech Concert</a></li><li class="tag-item"><a class="tag-link" href="/tags/nestjs/">NestJS</a></li><li class="tag-item"><a class="tag-link" href="/tags/nodejs/">NodeJS</a></li><li class="tag-item"><a class="tag-link" href="/tags/nodejs-framework/">NodeJS Framework</a></li><li class="tag-item"><a class="tag-link" href="/tags/nodejs/">Nodejs</a></li><li class="tag-item"><a class="tag-link" href="/tags/nothing타입-코틀린-kotlin/">Nothing타입, 코틀린, Kotlin</a></li><li class="tag-item"><a class="tag-link" href="/tags/oop-programming/">OOP Programming</a></li><li class="tag-item"><a class="tag-link" href="/tags/prototype/">Prototype</a></li><li class="tag-item"><a class="tag-link" href="/tags/queue/">Queue</a></li><li class="tag-item"><a class="tag-link" href="/tags/react-react-hooks/">React, React Hooks</a></li><li class="tag-item"><a class="tag-link" href="/tags/reactjs/">ReactJS</a></li><li class="tag-item"><a class="tag-link" href="/tags/reactjs-lifecycle/">ReactJS lifecycle</a></li><li class="tag-item"><a class="tag-link" href="/tags/reflow-and-repaint/">Reflow and Repaint</a></li><li class="tag-item"><a class="tag-link" href="/tags/requirejs/">RequireJS</a></li><li class="tag-item"><a class="tag-link" href="/tags/restful-api/">Restful API</a></li><li class="tag-item"><a class="tag-link" href="/tags/review/">Review</a></li><li class="tag-item"><a class="tag-link" href="/tags/solid-원칙/">SOLID 원칙</a></li><li class="tag-item"><a class="tag-link" href="/tags/ssr/">SSR</a></li><li class="tag-item"><a class="tag-link" href="/tags/san-francisco/">San francisco</a></li><li class="tag-item"><a class="tag-link" href="/tags/sentry/">Sentry</a></li><li class="tag-item"><a class="tag-link" href="/tags/session/">Session</a></li><li class="tag-item"><a class="tag-link" href="/tags/stack/">Stack</a></li><li class="tag-item"><a class="tag-link" href="/tags/tmon/">TMON</a></li><li class="tag-item"><a class="tag-link" href="/tags/tensorflow/">TensorFlow</a></li><li class="tag-item"><a class="tag-link" href="/tags/tree/">Tree</a></li><li class="tag-item"><a class="tag-link" href="/tags/tree-node/">Tree Node</a></li><li class="tag-item"><a class="tag-link" href="/tags/typescript/">Typescript</a></li><li class="tag-item"><a class="tag-link" href="/tags/umd/">UMD</a></li><li class="tag-item"><a class="tag-link" href="/tags/unit-test/">Unit test</a></li><li class="tag-item"><a class="tag-link" href="/tags/util-type/">Util type</a></li><li class="tag-item"><a class="tag-link" href="/tags/vitual-dom/">Vitual Dom</a></li><li class="tag-item"><a class="tag-link" href="/tags/vuejs/">VueJS</a></li><li class="tag-item"><a class="tag-link" href="/tags/vuejs/">Vuejs</a></li><li class="tag-item"><a class="tag-link" href="/tags/vuex/">Vuex</a></li><li class="tag-item"><a class="tag-link" href="/tags/webpack/">Webpack</a></li><li class="tag-item"><a class="tag-link" href="/tags/webpack-hmr/">Webpack HMR</a></li><li class="tag-item"><a class="tag-link" href="/tags/withinnovation/">Withinnovation</a></li><li class="tag-item"><a class="tag-link" href="/tags/d-ts/">d.ts</a></li><li class="tag-item"><a class="tag-link" href="/tags/interface/">interface</a></li><li class="tag-item"><a class="tag-link" href="/tags/네이버콘서트/">네이버콘서트</a></li><li class="tag-item"><a class="tag-link" href="/tags/멋쟁이-사자처럼/">멋쟁이 사자처럼</a></li><li class="tag-item"><a class="tag-link" href="/tags/소프트스킬/">소프트스킬</a></li><li class="tag-item"><a class="tag-link" href="/tags/스타트업/">스타트업</a></li><li class="tag-item"><a class="tag-link" href="/tags/스택오버플로우/">스택오버플로우</a></li><li class="tag-item"><a class="tag-link" href="/tags/애자일/">애자일</a></li><li class="tag-item"><a class="tag-link" href="/tags/여기어때/">여기어때</a></li><li class="tag-item"><a class="tag-link" href="/tags/유틸-타입/">유틸 타입</a></li><li class="tag-item"><a class="tag-link" href="/tags/인생전략71가지/">인생전략71가지</a></li><li class="tag-item"><a class="tag-link" href="/tags/인피니티-스크롤/">인피니티 스크롤</a></li><li class="tag-item"><a class="tag-link" href="/tags/제네릭타입/">제네릭타입</a></li><li class="tag-item"><a class="tag-link" href="/tags/최고의집합/">최고의집합</a></li><li class="tag-item"><a class="tag-link" href="/tags/커피한잔마시며-끝내는-vuejs/">커피한잔마시며 끝내는 VueJS</a></li><li class="tag-item"><a class="tag-link" href="/tags/콜스택/">콜스택</a></li><li class="tag-item"><a class="tag-link" href="/tags/타입스크립트/">타입스크립트</a></li><li class="tag-item"><a class="tag-link" href="/tags/티모니언/">티모니언</a></li><li class="tag-item"><a class="tag-link" href="/tags/티켓몬스터/">티켓몬스터</a></li><li class="tag-item"><a class="tag-link" href="/tags/프로그래머스/">프로그래머스</a></li><li class="tag-item"><a class="tag-link" href="/tags/하노이탑알고리즘/">하노이탑알고리즘</a></li><li class="tag-item"><a class="tag-link" href="/tags/해커톤/">해커톤</a></li><li class="tag-item"><a class="tag-link" href="/tags/호텔타임/">호텔타임</a></li><li class="tag-item"><a class="tag-link" href="/tags/회고/">회고</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">About</h3><div class="item__content"><p class="item__text">Martin(Younghoon Kim)</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Seoul, South Korea</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>hoons0131@gmail.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="/images/bg/avatar.png" alt="logo" title="프론트엔드 개발자 Martin의 사적인 블로그"></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/martinyounghoonkim" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:hoons0131@gmail.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li><li class="social-network__item"><a href="/atom.xml" target="_blank" title="rss"><i class="iconfont icon-rss"></i></a></li><li class="social-network__item"><a href="https://www.linkedin.com/in/younghoon-kim-2a1530149/" target="_blank" title="linkedin"><i class="iconfont icon-in"></i></a></li><li class="social-network__item"><a href="https://www.facebook.com/profile.php?id=100005693104994" target="_blank" title="facebook"><i class="iconfont icon-facebook"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><script>var disqus_shortname="blog-martinwork-co-kr",disqus_config=function(){this.page.url="http://blog.martinwork.co.kr/typescript/2019/05/28/typescript-util-types.html",this.page.identifier="/typescript/2019/05/28/typescript-util-types.html",this.page.title="Typescript의 기본 유틸 타입"};!function(){var t=document,e=t.createElement("script");e.src="https://"+disqus_shortname+".disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>