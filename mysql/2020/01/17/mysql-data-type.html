<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><title>MYSQL 데이터 타입 | RDBMS의 한 종류 MYSQL의 데이터 타입을 살펴보자 | Martin</title><meta name="keywords" content="'Mysql, 데이터타입',  MYSQL, MYSQL data Type, MYSQL 데이터 타입, 마이에스큐엘, 데이터 타입, "><meta name="description" content="RDBMS의 한 종류 MYSQL의 데이터 타입을 살펴보자, RDBMS의 한 종류 MYSQL의 데이터 타입을 살펴보자,MYSQL 데이터 타입"><meta property="og:image" content="/images/mysql/mysql.png"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="[object Object]"><meta name="designer" content="Martin"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="http://blog.martinwork.co.kr/mysql/2020/01/17/mysql-data-type.html"><link rel="icon" type="image/png" href="/images/favicon/favicon-32x32.png" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="프론트엔드 개발자 Martin의 사적인 블로그"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-109243056-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-109243056-1")</script><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(undefined)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="프론트엔드 개발자 Martin의 사적인 블로그" alt="프론트엔드 개발자 Martin의 사적인 블로그"><img src="/images/bg/logo_white_text.png" alt="프론트엔드 개발자 Martin의 사적인 블로그"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="Home" title="Home">Home</a></li><li class="nav__item"><a href="/archives" alt="Archive" title="Archive">Archive</a></li><li class="nav__item"><a href="/about" alt="About" title="About">About</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="/images/mysql/mysql.png" alt="MYSQL 데이터 타입"></div><header class="post__info"><h1 class="post__title">MYSQL 데이터 타입</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="https://github.com/martinYounghoonKim">Martin</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2020-01-17</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/mysql-데이터타입/">Mysql, 데이터타입</a></li></ul></div></div></header><div class="post__content"><h3 id="숫자형-데이터-타입"><a href="#숫자형-데이터-타입" class="headerlink" title="숫자형 데이터 타입"></a>숫자형 데이터 타입</h3><table><thead><tr><th>타입</th><th>정의</th><th>범위</th><th>UNSIGNED 사용가능 여부</th></tr></thead><tbody><tr><td>TINYINT(n)</td><td>정수형 데이터 타입</td><td>- 1 Byte(2^8)<br>- 128 ~ + 127 또는 0 ~ 255 수 표현 가능<br>- 1Byte(2^8)<br>- 128 ~ + 127 또는 0 ~ 255 수 표현 가능</td><td>O</td></tr><tr><td>SMALLINT(n)</td><td>정수형 데이터 타입</td><td>- 2 Byte(2^16)<br>- 32,768 ~ 32,167 또는 0 ~ 65536수 표현 가능</td><td>O</td></tr><tr><td>MEDIUMINT(n)</td><td>정수형 데이터 타입</td><td>- 3 Byte<br>- 8,388,608 ~ 8,388,607 또는 0 ~ 16,777,215 수 표현 가능</td><td>O</td></tr><tr><td>INT(n)</td><td>정수형 데이터 타입</td><td>- 4 Byte<br>- 2,147,483,648 ~ 2,147,483,647 또는 0 4,294,967,295 수 표현 가능</td><td>O</td></tr><tr><td>BIGINT(n)</td><td>정수형 데이터 타입(LONG)</td><td>- 8 byte<br>- 2^64 - 1 표현 가능(무한 수 표현 가능이라고도 함)</td><td>O</td></tr><tr><td>DECIMAL(m, d)</td><td>- 고정 소수형 데이터 타입고정(길이+1 byte)<br>- 화폐 데이터와 같이 데이터의 정확도를 요하는 경우에 주로 사용<br>- M의 최대값은 65, D는 소수 자릿수이며 0이면 소수점 가지지 않음</td><td>- 소수점을 사용한 형태<br>- Default: m ⇒ 10</td><td>X</td></tr><tr><td>FLOAT(n)</td><td>부동 소수형 데이터 타입</td><td>- 4 byte<br>- 부동 소수점을 사용한 형태</td><td>X</td></tr><tr><td>DOUBLE(n)</td><td>부동 소수형 데이터 타입</td><td>- 8 byte<br>- DOUBLE을 문자열로 저장</td><td>X</td></tr></tbody></table><h4 id="UNSIGNED-속성"><a href="#UNSIGNED-속성" class="headerlink" title="UNSIGNED 속성"></a>UNSIGNED 속성</h4><p><code>UNSIGNED</code> 속성을 부여하게 되면 해당 속성을 부여받은 컬럼에는 <code>음수값을 대입하지 못한다</code>. 결제 내역에 대한 테이블을 예시로 들어보도록 하겠다. 결제 금액은 음수값이 될 수 없음을 누구나 알 수 있을 것이다. 이런 경우 UNSIGNED 속성을 부여하여 음수값을 대입하지 못하게 할 뿐만 아니라 대입 가능한 숫자의 범위를 늘려줄 수 있다. 예제를 살펴보도록 하자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> payment</span><br><span class="line">(</span><br><span class="line">    uid <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    total_consume_mount <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (uid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>작성된 payment 테이블에 음수값을 대입해보도록 하자. 아마 아래와 같이 에러가 발생하는 것을 확인할 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> payment (uid, total_consume_mount)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">-100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ERROR 1264 (22003): Out of range value for column 'total_consume_mount' at row 1</span></span><br></pre></td></tr></table></figure><p>또한 기존 SIGNED 속성을 가진 INT 타입에는 최대 2,147,483,647까지 대입 가능한 반면 UNSIGNED 속성을 부여하면 대입 가능한 값이 4,294,967,295까지 늘어난 것을 확인할 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 대입 가능한 범위가 늘어남을 볼 수 있다.</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> payment <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">4294967295</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 하지만 그 이상의 값을 대입하려 할때면 다음과 같은 에러가 발생하는 것을 확인할 수 있다.</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> payment <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">4294967296</span>);</span><br><span class="line"><span class="comment">-- ERROR 1264 (22003): Out of range value for column 'total_consume_mount' at row 1</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="comment">#### Integer 타입의 N의 의미</span></span><br><span class="line">TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 공통적으로 MAXIMUM 값은 항상 N과는 무관하게 허용 가능한 범위는 동일하다. 그렇다면 이 N은 언제 사용하는 것일까? 그에 대한 답은 아래의 예제에서 찾을 수 있다.</span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> payment</span><br><span class="line">(</span><br><span class="line">    uid <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    total_consume_mount <span class="built_in">INT</span>(<span class="number">3</span>) ZEROFILL <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>, <span class="comment">-- ZEROFILL 속성을 부여한다.</span></span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (uid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> payment <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> payment;</span><br><span class="line">+<span class="comment">-----+---------------------+</span></span><br><span class="line">| uid | total_consume_mount |</span><br><span class="line">+<span class="comment">-----+---------------------+</span></span><br><span class="line">|   1 |                 001 |</span><br><span class="line">+<span class="comment">-----+---------------------+</span></span><br></pre></td></tr></table></figure><p>N 값은 ZEROFILL 속성과 함께 사용할 때 의미가 있다. 테이블을 생성할 때, ZEROFILL 속성을 주게되면 N 자릿수 이하의 값에 대해서 부여된 자리수를 항상 0으로 채운다. 만약 N 자릿수를 초과하게 되면 크게 의미가 없다. 또한 ZEROFILL 속성을 부여하게 되면 자동으로 UNSIGNED 속성이 붙게 된다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DESC payment;</span><br><span class="line"></span><br><span class="line">+<span class="comment">---------------------+--------------------------+------+-----+---------+-------+</span></span><br><span class="line">| Field               | Type                     | Null | Key | Default | Extra |</span><br><span class="line">+<span class="comment">---------------------+--------------------------+------+-----+---------+-------+</span></span><br><span class="line">| uid                 | bigint(20)               | NO   | MUL | NULL    |       |</span><br><span class="line">| total_consume_mount | int(3) unsigned zerofill | NO   |     | 000     |       |</span><br><span class="line">+<span class="comment">---------------------+--------------------------+------+-----+---------+-------+</span></span><br></pre></td></tr></table></figure><h4 id="고정-소수형-데이터-타입-DECIMAL-과-부동-소수형-데이터-타입-FLOAT-DOUBLE"><a href="#고정-소수형-데이터-타입-DECIMAL-과-부동-소수형-데이터-타입-FLOAT-DOUBLE" class="headerlink" title="고정 소수형 데이터 타입(DECIMAL)과 부동 소수형 데이터 타입(FLOAT, DOUBLE)"></a>고정 소수형 데이터 타입(DECIMAL)과 부동 소수형 데이터 타입(FLOAT, DOUBLE)</h4><p>DECIMAL 타입과 FLOAT, DOUBLE의 가장 큰 차이점은 고정 소수형 데이터 타입이냐, 부동 소수형 데이터 타입이냐에 따라 결정되게 된다. DECIMAL 타입의 경우 앞에서 총 2개의 설정을 값을 부여할 수 있다. 아래의 예제를 살펴보도록 하자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">wallet</span> (</span><br><span class="line">    uid <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    dollar <span class="built_in">DECIMAL</span>(<span class="number">5</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>, </span><br><span class="line">    mileage <span class="built_in">FLOAT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (uid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>dollar 컬럼에 DECIMAL(5,2)의 데이터 타입을 지정하였다. DECIMAL(M, D)에서 M에 해당하는 5의 경우 총 5자리의 숫자를 사용할 수 있다는 의미이고, D에 해당하는 2는 소수점을 2자리까지 지정하겠다라는 의미이다. 그렇다면 정수의 타입은 M-D(5-2)까지 저장할 수 있다는 것을 유추할 수 있다. 그렇게 DECIMAL(5,2) 데이터 타입의 범위는 -999.99 ~ 999.99이다.</p><p>각각의 DECIMAL과 FLOAT 타입에 동일한 데이터를 대입해보도록 하자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">wallet</span> <span class="keyword">VALUES</span> (<span class="keyword">default</span>, <span class="number">10.91</span>, <span class="number">10.91</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">wallet</span> <span class="keyword">VALUES</span> (<span class="keyword">default</span>, <span class="number">10.91</span>, <span class="number">10.91</span>);</span><br></pre></td></tr></table></figure><p>값을 값을 대입한 후, 조회를 해보면 값은 값이 저장된 것을 확인할 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">wallet</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">---------+--------+---------+</span></span><br><span class="line">| user_id | dollar | mileage |</span><br><span class="line">+<span class="comment">---------+--------+---------+</span></span><br><span class="line">|       1 |  10.91 |   10.91 |</span><br><span class="line">|       2 |  10.91 |   10.91 |</span><br><span class="line">+<span class="comment">---------+--------+---------+</span></span><br></pre></td></tr></table></figure><p>이렇게만 보면 큰 차이점은 없어 보인다. 하지만 아래와 같이 연산을 해보면 서로 다른 결과를 보인다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(dollar) decimal_type, <span class="keyword">SUM</span>(mileage) float_type <span class="keyword">FROM</span> <span class="keyword">wallet</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">--------------+-------------------+</span></span><br><span class="line">| decimal_type | float_type        |</span><br><span class="line">+<span class="comment">--------------+-------------------+</span></span><br><span class="line">|        21.82 | 21.81999969482422 |</span><br><span class="line">+<span class="comment">--------------+-------------------+</span></span><br></pre></td></tr></table></figure><p>DECIMAL 타입은 고동 소수형 데이터기 때문에 연산을 해도 정해진 자리수로 떨어지는 것을 확인할 수 있지만 FLOAT 타입의 경우, 의도치 않은 결과를 반환하는 것을 볼 수 있다. 그렇기 때문에 앞서의 표에서 <code>화폐 데이터와 같이 정확한 데이터</code>를 요할 경우 주로 사용한다.</p><h3 id="문자형-데이터-타입"><a href="#문자형-데이터-타입" class="headerlink" title="문자형 데이터 타입"></a>문자형 데이터 타입</h3><table><thead><tr><th>타입</th><th>정의</th><th>길이</th></tr></thead><tbody><tr><td>CHAR(n)</td><td>- 고정 길이 데이터 타입<br>- 지정된 길이보다 짧은 데이터 입력 시 나머지 길이는 공백으로 채워짐<br>- 검색시, PAD_CHAR_TO_FULL_LENGTH 모드를 설정하지 않으면 공백은 제거됨</td><td>0 ~ 255 (byte)</td></tr><tr><td>VACHAR(n)</td><td>- 가변 길이 데이터 타입<br>- 지정된 길이보다 짧은 데이터 입력시 공백으로 채우지 않음<br>-저장시 1-byte 혹은 2-byte 길이 Prefix 데이터를 저장. 이 Prefix 데이터는 값의 바이트 수에 대한 정보를 담는다.(<a href="https://dev.mysql.com/doc/refman/8.0/en/char.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/char.html</a>)</td><td>0 ~ 65,535 (byte)</td></tr><tr><td>TINYTEXT(n)</td><td>- 문자열 데이터 타입(최대 255 byte)<br>- TINYBLOB와 같은 길이값을 저장 가능(단 차이점은 저장 될때 nonbinary string으로 저장)<br><a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/blob.html</a></td><td>0 ~ 255 (byte)</td></tr><tr><td>TEXT(n)</td><td>- 문자열 데이터 타입(최대 65,535 byte)<br>- BLOB와 같은 길이값을 저장 가능(단 차이점은 저장 될때 nonbinary string으로 저장)</td><td>0 ~ 65,535 (byte)</td></tr><tr><td>MEDIUMTEXT(n)</td><td>- 문자열 데이터 타입(최대 16,777,215 byte)<br>- MEDIRMBLOB와 같은 길이값을 저장 가능(단 차이점은 저장 될때 nonbinary string으로 저장)</td><td>0 ~ 16,777,215 (byte)</td></tr><tr><td>LONGTEXT(n)</td><td>- 문자열 데이터 타입(최대 4,294,967,295 byte)<br>- LONGBLOB와 같은 길이값을 저장 가능(단 차이점은 저장 될때 nonbinary string으로 저장)</td><td>0 ~ 4,294,967,295 (byte)</td></tr></tbody></table><h4 id="범위값-초과"><a href="#범위값-초과" class="headerlink" title="범위값 초과"></a>범위값 초과</h4><p>먼저 예시로 유저 테이블을 생성해보도록 하자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</span><br><span class="line">    uid     <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="keyword">name</span>    <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="keyword">password</span> <span class="built_in">CHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    join_date DATETIME <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NOW</span>(),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (uid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>생성된 테이블에 샘플 데이터를 넣게 되어보도록 하자. 아래와 같이 비밀번호 컬럼의 범위 N 값 이내의 경우에는 정상적으로 데이터가 추가되는 것을 확인할 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">VALUES</span> (<span class="keyword">default</span>, <span class="string">'Martin'</span>, <span class="string">'1234567890'</span>, <span class="keyword">default</span>);</span><br></pre></td></tr></table></figure><p>하지만 N값의 범위를 초과하는 경우, 에러를 반환하는 것을 확인할 수 있다. 만약 <code>strict mode</code>가 설정되어 있지 않다면 나머지 값은 길이에 맞게 짤리고 저장은 될 것이다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">VALUES</span> (<span class="keyword">default</span>, <span class="string">'Martin'</span>, <span class="string">'12345678900'</span>, <span class="keyword">default</span>);</span><br><span class="line"><span class="comment">-- ERROR 1406 (22001): Data too long for column 'password' at row 1</span></span><br></pre></td></tr></table></figure><h3 id="날짜형-데이터-타입"><a href="#날짜형-데이터-타입" class="headerlink" title="날짜형 데이터 타입"></a>날짜형 데이터 타입</h3><table><thead><tr><th>타입</th><th>정의</th><th>길이</th><th>형식</th><th>길이</th></tr></thead><tbody><tr><td>DATE</td><td>날짜(년도, 월, 일) 형태의 기간 표현 데이터</td><td>3 byte</td><td>0000-00-00 (YYYY-MM-DD)</td><td>1000-01-01 ~ 9999-12-31</td></tr><tr><td>TIME</td><td>시간(시, 분, 초) 형태의 기간 표현 데이터</td><td>3 byte</td><td>00:00:00</td><td>.</td></tr><tr><td>DATETIME</td><td>날짜와 시간 형태의 기간 표현 데이터</td><td>8 byte</td><td>0000-00-00 00:00:00 (YYYY-MM-DD hh:mm:ss)</td><td>1000-01-01 00:00:00.000000 ~ 9999-12-31 23:59:59.999999</td></tr><tr><td>TIMESTAMP</td><td>날짜와 시간 형태의 기간 표현 데이터 타입 시스템 변경 시 자동으로 그 날짜와 시간이 저장</td><td>4 byte</td><td>Integer</td><td>.</td></tr><tr><td>YEAR</td><td>년도 표현 데이터 타입</td><td>1 byte</td><td>0000</td><td>.</td></tr></tbody></table><h3 id="이진-데이터-타입"><a href="#이진-데이터-타입" class="headerlink" title="이진 데이터 타입"></a>이진 데이터 타입</h3><table><thead><tr><th>타입</th><th>정의</th><th>길이</th></tr></thead><tbody><tr><td>BINARY(n) &amp; BYTE(n)</td><td>CHAR 형태의 이진 데이터 타입</td><td>최대 255 byte</td></tr><tr><td>VARBINARY(n)</td><td>VARCHAR 형태의 이진 데이터 타입</td><td>최대 65,535 byte</td></tr><tr><td>TINYBLOB(n)</td><td>이진 데이터 타입</td><td>최대 255 byte</td></tr><tr><td>BLOB(n)</td><td>이진 데이터 타입</td><td>최대 65,535 byte</td></tr><tr><td>MEDIUMBLOB(n)</td><td>이진 데이터 타입</td><td>최대 16,777,215 byte</td></tr><tr><td>LONGBLOB(n)</td><td>이진 데이터 타입</td><td>최대 4,294,967,295 byte</td></tr></tbody></table><h3 id="ENUM-타입"><a href="#ENUM-타입" class="headerlink" title="ENUM 타입"></a>ENUM 타입</h3><p>ENUM 타입의 경우에는 실제 실무에서 사용할 수 있는 경우가 크게 많아 보이지는 않는다. 새로운 ENUM 타입이 생겼을 경우나 혹은 정렬을 해야하는 경우 비효율적이기 때문이다. 그래도 어떠한 타입인지 알고 쓸지 말지를 결정하는 것이 더 좋기 때문에 예제를 통해 한번 살펴보도록 하자. 먼저 아래와 같이 테이블 생성해도록 하자. 여기에서 중요한 것을 size</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> enum_test (</span><br><span class="line">  <span class="keyword">size</span> ENUM(<span class="string">'x-small'</span>, <span class="string">'small'</span>, <span class="string">'medium'</span>, <span class="string">'large'</span>, <span class="string">'x-large'</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  color ENUM(<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'black'</span>, <span class="string">'white'</span>, <span class="string">'pink'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>이렇게 선언된 테이블에 총 2가지 방법은 데이터 삽입이 가능하다. 첫번째 방법은 아래와 같이 ENUM 타입 중 한가지 타입을 이용하여 넣는 방법이다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> enum_test <span class="keyword">VALUES</span> (<span class="string">'x-small'</span>, <span class="string">'red'</span>);</span><br><span class="line"></span><br><span class="line">+<span class="comment">---------+-------+</span></span><br><span class="line">| size    | color |</span><br><span class="line">+<span class="comment">---------+-------+</span></span><br><span class="line">| x-small | red   |</span><br><span class="line">+<span class="comment">---------+-------+</span></span><br></pre></td></tr></table></figure><p>두번째 방법은 아래와 같이 저장된 ENUM 타입의 ordering 숫자로 저장하는 법이다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> enum_test <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">+<span class="comment">---------+-------+</span></span><br><span class="line">| size    | color |</span><br><span class="line">+<span class="comment">---------+-------+</span></span><br><span class="line">| x-small | red   |</span><br><span class="line">+<span class="comment">---------+-------+</span></span><br></pre></td></tr></table></figure><p>기본적으로 ENUM 값을 지정하지 않으면 NULL로 삽입되지만, 만약 NULL값을 원하지 않는다면, size 컬럼과 같이 NOT NULL 속성을 추가해주면 된다.</p><h4 id="ENUM-타입-조회하기"><a href="#ENUM-타입-조회하기" class="headerlink" title="ENUM 타입 조회하기"></a>ENUM 타입 조회하기</h4><p>ENUM 타입은 앞에서 살펴보았듯 ordering 숫자로 저장된다. 그렇기 때문에 해당 필드값을 기준으로 정렬하여 조회할 수 있다. 일단 정렬되는 데이터를 확인하기 위해 몇가지 데이터를 추가해보자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> enum_test <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> enum_test <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> enum_test <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> enum_test <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> enum_test <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">+<span class="comment">---------+-------+</span></span><br><span class="line">| size    | color |</span><br><span class="line">+<span class="comment">---------+-------+</span></span><br><span class="line">| x-small | red   |</span><br><span class="line">| x-small | red   |</span><br><span class="line">| medium  | blue  |</span><br><span class="line">| small   | white |</span><br><span class="line">| large   | red   |</span><br><span class="line">| x-large | white |</span><br><span class="line">+<span class="comment">---------+-------+</span></span><br></pre></td></tr></table></figure><p>몇가지 데이터를 추가한 후, 한번 아래와 같이 데이터 정렬을 해자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> enum_test <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">size</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">---------+-------+</span></span><br><span class="line">| size    | color |</span><br><span class="line">+<span class="comment">---------+-------+</span></span><br><span class="line">| x-small | red   |</span><br><span class="line">| x-small | red   |</span><br><span class="line">| small   | white |</span><br><span class="line">| medium  | blue  |</span><br><span class="line">| large   | red   |</span><br><span class="line">| x-large | white |</span><br><span class="line">+<span class="comment">---------+-------+</span></span><br></pre></td></tr></table></figure><p>size를 기준으로 정렬을 했을 경우, 위와 같이 저장된 ordering 번호에 맞게 정렬되는 것을 확인할 수 있다. 그렇다면 만약 알파벳 순서대로 조회하고자 한다면 어떻게 해야할까? 제일 좋은 것은 알파벳 순서대로 저장하는 것이지만, 현실 가능성은 떨어진다. 중간에 어떠한 ENUM 타입이 생길지도 모르는데, 그걸 모두 고려해서 알파벳 순서대로 테이블을 추가하기란 쉽지 않다. 알파벳 순서대로 조회하기 위해선 다음과 같이 조회하면 된다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> enum_test <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">CAST</span>(<span class="keyword">size</span> <span class="keyword">AS</span> <span class="built_in">CHAR</span>);</span><br><span class="line"></span><br><span class="line">+<span class="comment">---------+-------+</span></span><br><span class="line">| size    | color |</span><br><span class="line">+<span class="comment">---------+-------+</span></span><br><span class="line">| large   | red   |</span><br><span class="line">| medium  | blue  |</span><br><span class="line">| small   | white |</span><br><span class="line">| x-large | white |</span><br><span class="line">| x-small | red   |</span><br><span class="line">| x-small | red   |</span><br><span class="line">+<span class="comment">---------+-------+</span></span><br></pre></td></tr></table></figure><p>ENUM 타입인 size를 CHAR 형태로 타입 캐스팅 해준 후, 조회를 하는 것이다. 하지만 이또한 데이터가 많아질수록 성능이 안좋아질테니, 되도록이면 ENUM 타입보단 다른 형태의 데이터를 이용하여 저장하고 각각의 ENUM 타입에 대한 맵핑은 각각의 애플리케이션에서 정의하는 것이 좋을 것 같다.</p><h3 id="SET-데이터-타입"><a href="#SET-데이터-타입" class="headerlink" title="SET 데이터 타입"></a>SET 데이터 타입</h3><p>마지막으로 살펴볼 타입은 SET 데이터 타입이다. SET 데이터 타입은 ENUM 타입이랑 다르게 중복값을 허용한다. 먼저 예시를 보기 위해 샘플로 아래와 같은 영화 장르 테이블을 생성하도록 하자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> genre (</span><br><span class="line">   <span class="keyword">size</span> <span class="keyword">SET</span>(<span class="string">'horror'</span>, <span class="string">'comic'</span>, <span class="string">'romance'</span>, <span class="string">'documentary'</span>, <span class="string">'sf'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>모두 알다시피 하나의 영화에는 여러개의 장르를 선택할 수 있다. 코믹이면서 로맨스일 수도 있고, 공포이면서 SF일 수도 있다. 일단 하나의 영화에 하나의 장르만 존재한다고 가정하고 데이터를 추가해보자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> genre <span class="keyword">VALUES</span> (<span class="string">'horror'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> genre <span class="keyword">VALUES</span> (<span class="string">'comic'</span>);</span><br></pre></td></tr></table></figure><p>그렇다면 만약 여러개의 장르를 가져야할때는 어떻게 해야할까?</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> genre <span class="keyword">VALUES</span> (<span class="string">'comic,romance'</span>);</span><br></pre></td></tr></table></figure><p>중복으로 넣어줄 데이터를 쉼표(,)와 함께 추가해주면 된다. 다만 여기에서 중요한 것은 쉼표 뒤에 띄어쓰기가 되어있으면 안되고, 무조건 붙어있어야 한다. 만약 띄어쓰기를 한 후 데이터를 추가하려고 하면 아래와 같은 에러가 발생한다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> genre <span class="keyword">VALUES</span> (<span class="string">'comic,romance'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ERROR 1265 (01000): Data truncated for column 'size' at row 1</span></span><br></pre></td></tr></table></figure><p>또 다른 방법으로는 SET 데이터 타입의 주요한 특징에서 찾을 수 있다. SET 데이터의 경우 하나의 값마다 순서대로 Binary 값이 부여된다. Jenre 데이터 테이블의 SET 데이터를 바이너리로 표현하면 다음과 같이 표현할 수 있다.</p><table><thead><tr><th>VALUE</th><th>DECIMAL</th><th>BINARY</th></tr></thead><tbody><tr><td>horror</td><td>1</td><td>00001</td></tr><tr><td>comic</td><td>2</td><td>00010</td></tr><tr><td>romance</td><td>4</td><td>00100</td></tr><tr><td>documentary</td><td>8</td><td>01000</td></tr><tr><td>sf</td><td>16</td><td>10000</td></tr></tbody></table><p>이를 이용하여 다음과 같이 넣어줄 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> genre <span class="keyword">VALUES</span> (<span class="number">1</span>); <span class="comment">-- INSERT INTO genre VALUES ('horror'); 와 같다.</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> genre <span class="keyword">VALUES</span> (<span class="number">7</span>); <span class="comment">-- INSERT INTO genre VALUES ('horror,comic,romance'); 와 같다.</span></span><br></pre></td></tr></table></figure><h4 id="SET-데이터-타입-조회하기"><a href="#SET-데이터-타입-조회하기" class="headerlink" title="SET 데이터 타입 조회하기"></a>SET 데이터 타입 조회하기</h4><p>SET 데이터를 조회하는 방법은 여러가지가 있다. 일단 첫번째로 일반적인 방법으로 조회할 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 단일 조건을 이용하여 조회하는 경우</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> genre <span class="keyword">WHERE</span> <span class="keyword">size</span>=<span class="string">'horror'</span>; <span class="comment">-- 정확하게 horror 값만 가지고 있는 데이터만 조회 가능하다.</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> genre <span class="keyword">WHERE</span> <span class="keyword">size</span> <span class="keyword">LIKE</span> <span class="string">'%horror%'</span>; <span class="comment">-- horror 값을 포함한 데이터 모두가 조회 가능하다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 여러 조건을 이용하여 조회하는 경우</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> genre <span class="keyword">WHERE</span> <span class="keyword">size</span>=<span class="string">'horror,romance'</span>; <span class="comment">-- 정확하게 두가지 값을 모두 가지고 있는 데이터만 조회 가능하다.</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> genre <span class="keyword">WHERE</span> <span class="keyword">size</span> <span class="keyword">LIKE</span> <span class="string">'%horror%'</span> <span class="keyword">AND</span> <span class="keyword">size</span> <span class="keyword">LIKE</span> <span class="string">'%romance%'</span>; <span class="comment">-- 'horror'와 'romance' 값 모두 가지고 있는 데이터 모두 조회 가능하다.</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> genre <span class="keyword">WHERE</span> <span class="keyword">size</span> &amp; <span class="number">1</span> <span class="keyword">AND</span> <span class="keyword">size</span> &amp; <span class="number">4</span>; <span class="comment">-- 위와 도잉ㄹ하다.</span></span><br></pre></td></tr></table></figure><p>두번째 방법은 비트 연산자를 활용하는 방법이다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> genre <span class="keyword">WHERE</span> <span class="keyword">size</span> &amp; <span class="number">1</span>; <span class="comment">-- SELECT * FROM genre WHERE size LIKE '%horror%'; 와 동일하다.</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> genre <span class="keyword">WHERE</span> <span class="keyword">size</span> &amp; <span class="number">00001</span>; <span class="comment">-- 위와 동일하다.</span></span><br></pre></td></tr></table></figure><p>마지막 방법은 FIND_IN_SET 함수를 이용하는 것이다. 이 함수는 첫번째 인자로는 SET 의 값을, 두번째 인자로는 필드 이름을 넣어주면 저장되 있다면 저장된 순서값을, 저장되어있지 않다면 0을 반환한다. 아래의 예제를 살펴보도록 하자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> FIND_IN_SET(<span class="string">'romance'</span>, <span class="keyword">size</span>) <span class="keyword">FROM</span> genre;</span><br></pre></td></tr></table></figure><p>이와 같이 조회하면 romance가 저장되어 있다면 3을 그렇지 않다면 면 0을 반환하는 것을 확인할 수 있다. 이 함수를 이용한다면 다음과 같은 조건으로 조회할 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> genre <span class="keyword">WHERE</span> FIND_IN_SET(<span class="string">'romance'</span>, <span class="keyword">size</span>) &gt; <span class="number">0</span>; <span class="comment">-- romance 값이 저장된 모든 데이터가 조회 가능하다.</span></span><br></pre></td></tr></table></figure><p>지금까지 MYSQL 의 데이터 타입에 대해서 살펴보았다. 혹여라도 이와 관련된 소스를 확인하고 싶다면 <a href="https://github.com/MartinYounghoonKim/technical-debt-repayment-project/blob/master/mysql/select_query.sql" target="_blank" rel="noopener">여기</a>에서 확인할 수 있다.</p><div class="post-announce">현재 이커머스회사에서 frontend 개발자로 업무를 진행하고 있는 <a href="https://github.com/martinYounghoonKim">Martin</a> 입니다. 글을 읽으시고 궁금한 점은 댓글 혹은 메일(hoons0131@gmail.com)로 연락해주시면 빠른 회신 드리도록 하겠습니다. 이 외에도 네트워킹에 대해서는 언제나 환영입니다.：Martin（<a href="https://github.com/martinYounghoonKim">https://github.com/martinYounghoonKim</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/review/2020/01/07/remembrance-in-2019.html" title="2019년의 회고"><i class="iconfont icon-prev"></i>2019년의 회고</a></div><div class="post__prev post__prev--right"></div></div></div></article><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-6986373452203090" data-ad-slot="3762948283" data-ad-format="auto" data-full-width-responsive="true"></ins><script>window.onload=function(){(adsbygoogle=window.adsbygoogle||[]).push({})}</script><div id="disqus_thread"></div></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">Introduction</h3><p class="block__text">E-Commerce에서 Front-end 개발을 하고 있는 마틴입니다. 안정성 있는 서비스 구축과 TDD 프로그래밍에 관심이 많으며, 긍정적인 네트워킹에 대해서도 언제나 환영입니다. 저와의 네트워킹을 원하시는 분은 언제든 편하게 SNS나 게시글의 댓글 혹은 이메일을 통해 연락주시면 최대한 빨리 회신드리도록 하겠습니다:)</p></div><div class="sidebar__block"><h3 class="block__title">Categories</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/theory/">theory</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/webpack/">Webpack</a><span class="block-list-count">6</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/vuejs/">VueJS</a><span class="block-list-count">9</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/unit-test/">Unit Test</a><span class="block-list-count">3</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/typescript/">Typescript</a><span class="block-list-count">6</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/theory/">Theory</a><span class="block-list-count">12</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/review/">Review</a><span class="block-list-count">12</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/reactjs/">ReactJS</a><span class="block-list-count">2</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/react/">React</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/nodejs/">NodeJS</a><span class="block-list-count">3</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/mysql/">Mysql</a><span class="block-list-count">2</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/kotlin/">Kotlin</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/javascript/">Javascript</a><span class="block-list-count">15</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/devops/">Devops</a><span class="block-list-count">10</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/ai/">AI</a><span class="block-list-count">3</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">Latest Post</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/mysql/2020/01/17/mysql-data-type.html" title="MYSQL 데이터 타입"><div class="item__cover"><img src="/images/mysql/mysql.png" alt="MYSQL 데이터 타입"></div><div class="item__info"><h3 class="item__title">MYSQL 데이터 타입</h3><span class="item__text">2020-01-17</span></div></a></li><li class="latest-post-item"><a href="/review/2020/01/07/remembrance-in-2019.html" title="2019년의 회고"><div class="item__cover"><img src="/images/review/retro01.jpg" alt="2019년의 회고"></div><div class="item__info"><h3 class="item__title">2019년의 회고</h3><span class="item__text">2020-01-07</span></div></a></li><li class="latest-post-item"><a href="/theory/2019/12/15/ipv4-address.html" title="IPv4 주소 체계"><div class="item__cover"><img src="/images/theory/ipv4-address00.png" alt="IPv4 주소 체계"></div><div class="item__info"><h3 class="item__title">IPv4 주소 체계</h3><span class="item__text">2019-12-15</span></div></a></li><li class="latest-post-item"><a href="/kotlin/2019/11/24/nothing-type-in-kotlin.html" title="Kotlin의 Nothing 타입"><div class="item__cover"><img src="/images/kotlin/kotlin.png" alt="Kotlin의 Nothing 타입"></div><div class="item__info"><h3 class="item__title">Kotlin의 Nothing 타입</h3><span class="item__text">2019-11-24</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">Tags</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/2018회고/">2018회고</a></li><li class="tag-item"><a class="tag-link" href="/tags/2019회고-coupang-쿠팡/">2019회고, Coupang, 쿠팡</a></li><li class="tag-item"><a class="tag-link" href="/tags/ai/">AI</a></li><li class="tag-item"><a class="tag-link" href="/tags/aws/">AWS</a></li><li class="tag-item"><a class="tag-link" href="/tags/aws-s3/">AWS S3</a></li><li class="tag-item"><a class="tag-link" href="/tags/array/">Array</a></li><li class="tag-item"><a class="tag-link" href="/tags/authenticate/">Authenticate</a></li><li class="tag-item"><a class="tag-link" href="/tags/awwwards-2018/">Awwwards 2018</a></li><li class="tag-item"><a class="tag-link" href="/tags/back-end/">Back-end</a></li><li class="tag-item"><a class="tag-link" href="/tags/backend/">Backend</a></li><li class="tag-item"><a class="tag-link" href="/tags/binary-search/">Binary Search</a></li><li class="tag-item"><a class="tag-link" href="/tags/csr/">CSR</a></li><li class="tag-item"><a class="tag-link" href="/tags/chai/">Chai</a></li><li class="tag-item"><a class="tag-link" href="/tags/chrome-extension/">Chrome extension</a></li><li class="tag-item"><a class="tag-link" href="/tags/clean-code/">Clean code</a></li><li class="tag-item"><a class="tag-link" href="/tags/commonjs/">CommonJS</a></li><li class="tag-item"><a class="tag-link" href="/tags/conference/">Conference</a></li><li class="tag-item"><a class="tag-link" href="/tags/cookie/">Cookie</a></li><li class="tag-item"><a class="tag-link" href="/tags/database/">Database</a></li><li class="tag-item"><a class="tag-link" href="/tags/dev-ops/">Dev-ops</a></li><li class="tag-item"><a class="tag-link" href="/tags/devops/">Devops</a></li><li class="tag-item"><a class="tag-link" href="/tags/docker/">Docker</a></li><li class="tag-item"><a class="tag-link" href="/tags/ecma-script/">ECMA script</a></li><li class="tag-item"><a class="tag-link" href="/tags/eslint/">Eslint</a></li><li class="tag-item"><a class="tag-link" href="/tags/express/">Express</a></li><li class="tag-item"><a class="tag-link" href="/tags/first-class-object/">First Class Object</a></li><li class="tag-item"><a class="tag-link" href="/tags/flux/">Flux</a></li><li class="tag-item"><a class="tag-link" href="/tags/google-cloud-platform/">Google Cloud Platform</a></li><li class="tag-item"><a class="tag-link" href="/tags/hash-table/">Hash table</a></li><li class="tag-item"><a class="tag-link" href="/tags/ipv4-network-ip/">IPv4, Network, IP</a></li><li class="tag-item"><a class="tag-link" href="/tags/immutablejs/">ImmutableJS</a></li><li class="tag-item"><a class="tag-link" href="/tags/jwt/">JWT</a></li><li class="tag-item"><a class="tag-link" href="/tags/jwt-token/">JWT Token</a></li><li class="tag-item"><a class="tag-link" href="/tags/javascript/">Javascript</a></li><li class="tag-item"><a class="tag-link" href="/tags/javascript-framework/">Javascript Framework</a></li><li class="tag-item"><a class="tag-link" href="/tags/javascript-method/">Javascript Method</a></li><li class="tag-item"><a class="tag-link" href="/tags/javascript-디자인-패턴/">Javascript 디자인 패턴</a></li><li class="tag-item"><a class="tag-link" href="/tags/karma/">Karma</a></li><li class="tag-item"><a class="tag-link" href="/tags/linear-regression/">Linear Regression</a></li><li class="tag-item"><a class="tag-link" href="/tags/list/">List</a></li><li class="tag-item"><a class="tag-link" href="/tags/machine-learning/">Machine learning</a></li><li class="tag-item"><a class="tag-link" href="/tags/mocha/">Mocha</a></li><li class="tag-item"><a class="tag-link" href="/tags/moment/">Moment</a></li><li class="tag-item"><a class="tag-link" href="/tags/momentjs/">MomentJS</a></li><li class="tag-item"><a class="tag-link" href="/tags/mongodb/">MongoDB</a></li><li class="tag-item"><a class="tag-link" href="/tags/mysql/">Mysql</a></li><li class="tag-item"><a class="tag-link" href="/tags/mysql-데이터타입/">Mysql, 데이터타입</a></li><li class="tag-item"><a class="tag-link" href="/tags/naver-tech-concert/">Naver Tech Concert</a></li><li class="tag-item"><a class="tag-link" href="/tags/nodejs/">NodeJS</a></li><li class="tag-item"><a class="tag-link" href="/tags/nodejs/">Nodejs</a></li><li class="tag-item"><a class="tag-link" href="/tags/nothing타입-코틀린-kotlin/">Nothing타입, 코틀린, Kotlin</a></li><li class="tag-item"><a class="tag-link" href="/tags/oop-programming/">OOP Programming</a></li><li class="tag-item"><a class="tag-link" href="/tags/prototype/">Prototype</a></li><li class="tag-item"><a class="tag-link" href="/tags/queue/">Queue</a></li><li class="tag-item"><a class="tag-link" href="/tags/react-react-hooks/">React, React Hooks</a></li><li class="tag-item"><a class="tag-link" href="/tags/reactjs/">ReactJS</a></li><li class="tag-item"><a class="tag-link" href="/tags/reactjs-lifecycle/">ReactJS lifecycle</a></li><li class="tag-item"><a class="tag-link" href="/tags/reflow-and-repaint/">Reflow and Repaint</a></li><li class="tag-item"><a class="tag-link" href="/tags/requirejs/">RequireJS</a></li><li class="tag-item"><a class="tag-link" href="/tags/restful-api/">Restful API</a></li><li class="tag-item"><a class="tag-link" href="/tags/review/">Review</a></li><li class="tag-item"><a class="tag-link" href="/tags/solid-원칙/">SOLID 원칙</a></li><li class="tag-item"><a class="tag-link" href="/tags/ssr/">SSR</a></li><li class="tag-item"><a class="tag-link" href="/tags/san-francisco/">San francisco</a></li><li class="tag-item"><a class="tag-link" href="/tags/sentry/">Sentry</a></li><li class="tag-item"><a class="tag-link" href="/tags/session/">Session</a></li><li class="tag-item"><a class="tag-link" href="/tags/stack/">Stack</a></li><li class="tag-item"><a class="tag-link" href="/tags/tmon/">TMON</a></li><li class="tag-item"><a class="tag-link" href="/tags/tensorflow/">TensorFlow</a></li><li class="tag-item"><a class="tag-link" href="/tags/tree/">Tree</a></li><li class="tag-item"><a class="tag-link" href="/tags/tree-node/">Tree Node</a></li><li class="tag-item"><a class="tag-link" href="/tags/typescript/">Typescript</a></li><li class="tag-item"><a class="tag-link" href="/tags/umd/">UMD</a></li><li class="tag-item"><a class="tag-link" href="/tags/unit-test/">Unit test</a></li><li class="tag-item"><a class="tag-link" href="/tags/util-type/">Util type</a></li><li class="tag-item"><a class="tag-link" href="/tags/vitual-dom/">Vitual Dom</a></li><li class="tag-item"><a class="tag-link" href="/tags/vuejs/">VueJS</a></li><li class="tag-item"><a class="tag-link" href="/tags/vuejs/">Vuejs</a></li><li class="tag-item"><a class="tag-link" href="/tags/vuex/">Vuex</a></li><li class="tag-item"><a class="tag-link" href="/tags/webpack/">Webpack</a></li><li class="tag-item"><a class="tag-link" href="/tags/webpack-hmr/">Webpack HMR</a></li><li class="tag-item"><a class="tag-link" href="/tags/withinnovation/">Withinnovation</a></li><li class="tag-item"><a class="tag-link" href="/tags/d-ts/">d.ts</a></li><li class="tag-item"><a class="tag-link" href="/tags/interface/">interface</a></li><li class="tag-item"><a class="tag-link" href="/tags/네이버콘서트/">네이버콘서트</a></li><li class="tag-item"><a class="tag-link" href="/tags/멋쟁이-사자처럼/">멋쟁이 사자처럼</a></li><li class="tag-item"><a class="tag-link" href="/tags/소프트스킬/">소프트스킬</a></li><li class="tag-item"><a class="tag-link" href="/tags/스타트업/">스타트업</a></li><li class="tag-item"><a class="tag-link" href="/tags/스택오버플로우/">스택오버플로우</a></li><li class="tag-item"><a class="tag-link" href="/tags/애자일/">애자일</a></li><li class="tag-item"><a class="tag-link" href="/tags/여기어때/">여기어때</a></li><li class="tag-item"><a class="tag-link" href="/tags/유틸-타입/">유틸 타입</a></li><li class="tag-item"><a class="tag-link" href="/tags/인생전략71가지/">인생전략71가지</a></li><li class="tag-item"><a class="tag-link" href="/tags/인피니티-스크롤/">인피니티 스크롤</a></li><li class="tag-item"><a class="tag-link" href="/tags/제네릭타입/">제네릭타입</a></li><li class="tag-item"><a class="tag-link" href="/tags/최고의집합/">최고의집합</a></li><li class="tag-item"><a class="tag-link" href="/tags/커피한잔마시며-끝내는-vuejs/">커피한잔마시며 끝내는 VueJS</a></li><li class="tag-item"><a class="tag-link" href="/tags/콜스택/">콜스택</a></li><li class="tag-item"><a class="tag-link" href="/tags/타입스크립트/">타입스크립트</a></li><li class="tag-item"><a class="tag-link" href="/tags/티모니언/">티모니언</a></li><li class="tag-item"><a class="tag-link" href="/tags/티켓몬스터/">티켓몬스터</a></li><li class="tag-item"><a class="tag-link" href="/tags/프로그래머스/">프로그래머스</a></li><li class="tag-item"><a class="tag-link" href="/tags/하노이탑알고리즘/">하노이탑알고리즘</a></li><li class="tag-item"><a class="tag-link" href="/tags/해커톤/">해커톤</a></li><li class="tag-item"><a class="tag-link" href="/tags/호텔타임/">호텔타임</a></li><li class="tag-item"><a class="tag-link" href="/tags/회고/">회고</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">About</h3><div class="item__content"><p class="item__text">Martin(Younghoon Kim)</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Seoul, South Korea</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>hoons0131@gmail.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="/images/bg/avatar.png" alt="logo" title="프론트엔드 개발자 Martin의 사적인 블로그"></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/martinyounghoonkim" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:hoons0131@gmail.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li><li class="social-network__item"><a href="/atom.xml" target="_blank" title="rss"><i class="iconfont icon-rss"></i></a></li><li class="social-network__item"><a href="https://www.linkedin.com/in/younghoon-kim-2a1530149/" target="_blank" title="linkedin"><i class="iconfont icon-in"></i></a></li><li class="social-network__item"><a href="https://www.facebook.com/profile.php?id=100005693104994" target="_blank" title="facebook"><i class="iconfont icon-facebook"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><script>var disqus_shortname="blog-martinwork-co-kr",disqus_config=function(){this.page.url="http://blog.martinwork.co.kr/mysql/2020/01/17/mysql-data-type.html",this.page.identifier="/mysql/2020/01/17/mysql-data-type.html",this.page.title="MYSQL 데이터 타입"};!function(){var t=document,e=t.createElement("script");e.src="https://"+disqus_shortname+".disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>